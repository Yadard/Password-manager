from random import randrange as rrg

sample = ['2', '25']
morse_to_digit = {',----': '1', ',,---': '2', ',,,--': '3', ',,,,-': '4', ',,,,,': '5', '-,,,,': '6', '--,,,': '7',
                  '---,,': '8', '----,': '9', '-----': '0'}
symbols = {'#': "digits", '&': "char", '$': "origin", '%': 'convert_to_ASCII_chars'}
digit_to_morse = {v: k for k, v in morse_to_digit.items()}


def get_synonyms(key: int, length: int, website='facebook') -> dict:
    """
    :param key: the key generated to the user
    :param length: length of that password
    :param website: website of the password
    :return: a dict containing a two list one for the synonyms of dots and lines, with the keywords: 'line' for lines and 'dot' for dots
    """
    x = str(key)[:round(len(str(key)) / 2)]  # get the first {round(len(key)/2)} digits of the key
    y = 0
    for digit in x:
        y = y + int(digit)  # adds every digit of the number result of the first {round(len(key)/2)} digits
    dot = y  # gets the value to use to get the synonyms of dot
    x = str(key)[round(len(str(key)) / 2) * -1:]
    y = 0
    for digit in x:
        y = y + int(digit)
    line = y  # do the same to lines, but with last digits
    dot_synonyms = [dot, round(dot * length), round(dot * ord(website[0])), '*', '@', ',']
    # TODO make ASCIIs char with unique calculus make part of the dots and lines synonyms.
    # make dot a synonyms and make round of (dot*length) and round of (dot*ASCII_value(website[0]))
    dot = turn_into_1digit(dot_synonyms)
    line_synonyms = [line, round(line * length), round(line * ord(website[0])), '_', '=', '-']
    # do the same for lines
    line = turn_into_1digit(line_synonyms)
    synonyms = {'line': line,
                'dot': dot}  # makes a dict with the synonyms of the list of synonyms of line and dot storaged on it
    return synonyms


def turn_into_1digit(Lista: list) -> list:
    """
    Gets all numbers that are > 9 and make it into a 1 digit number by adding every digit
    of that number and after this tries to find the results that are repeated and remove them.\n
    :param Lista: A list to iterate through
    :return: The result as a new list
    """
    i = 0
    while i < len(Lista):  # goes through every item on Lista
        try:
            if type(Lista[i]) is int:  # makes sure it's a int
                foo = 0
                while Lista[i] > 9:  # see if it's a 2 ou more digit number
                    if foo > 9:  # needed because 'foo' can storage a double digit number and get through
                        x = 0
                        for digit in str(foo):
                            x = x + int(digit)  # uses x to make every digit from 'foo' to add each other
                            foo = x
                    else:
                        for digit in str(Lista[i]):  # uses foo this time to get every digit from the Lista.item
                            foo = foo + int(digit)
                    Lista[i] = foo
        except TypeError and IndexError:  # if it's a str do nothing
            pass
        i += 1
    for i in range(len(Lista)):
        for j in range(len(Lista)):
            try:
                if Lista[i] == Lista[j] and i != j:
                    Lista.remove(Lista[j])
            except IndexError:
                pass
    for i in range(len(Lista)):  # making every item a str, to avoid problems in 'decrypt' func.
        if not isinstance(Lista[i], str):
            Lista[i] = str(Lista[i])
    return Lista


def rid_equals(modifiable_list: list, reference_list: list) -> list:
    """
    get two list and removes the elements of the first list that are
    already on the second list.\n
    :param modifiable_list: list to remove repeated values
    :param reference_list: reference list to get repeated values
    :return: a modified list without repeated values with the reference list
    """
    rid_list = list()
    for i in modifiable_list:
        for j in reference_list:
            if i == j:
                rid_list.append(i)
    for i in rid_list:
        modifiable_list.remove(i)
    return modifiable_list


def encrypt(string: str, length: int, key: int, website='facebook') -> str:
    """
    Encrypts a string with a morse code system but with new synonyms for "dots"(.) and "lines"(-),
    based on the key, length and website of the created password.\n
    :rtype: object
    :param string: A string to encrypt, *only work with numbers
    :param length: The length of the password, used for the synonyms
    :param key: key generated by the root_password, used for the synonyms
    :param website: Website which the password belongs, used for the synonyms
    :return: return a encrypted version of a string. //can be decrypted with the func, "decrypt"
    """
    synonyms = get_synonyms(key, length, website)
    synonyms['dot'] = rid_equals(synonyms['dot'], synonyms['line'])
    x = ''
    for char in string:
        if not(char == '.' or char in symbols):
            x += digit_to_morse[char]  # uses a morse dict to convert chars
        elif char == '.':
            x += char
        elif char in symbols:
            x += char
    y = ""
    for element in x:
        if element == ',':
            y += str(synonyms['dot'][rrg(len(synonyms['dot']))])  # replaces the dots for a random synonyms
        elif element == '-':
            y += str(synonyms['line'][rrg(len(synonyms['line']))])  # replaces the lines for a random synonyms
        elif element == '.':
            y += '.'
        elif element in symbols:
            y += element
    return y


def decrypt(target_string, length, key, website='facebook'):
    """
    Decrypt a message that was encrypt by the "encrypt" function
    It use morse code with a list of character that can be used as replace
    for the standard '.'(dot) and '-'(line).

    :param target_string: string that you want to decrypt, *only work with numbers
    :param length: length determined for the root password, used to create the synonyms
    :param key: key generated to crypt the password data, used to create the synonyms
    :param website: website which the password belongs to, used to create the synonyms
    :return: return a string with the target_string decrypted
    """
    synonyms = get_synonyms(key, length, website)
    synonyms['dot'] = rid_equals(synonyms['dot'], synonyms['line'])
    x = ''
    for char in target_string:
        if char in synonyms['dot']:  # see if that char is in the synonyms list
            x += ','
        elif char in synonyms['line']:
            x += '-'
        elif char == ".":
            x += '.'
        elif char in symbols:
            x += char
    z = ''
    y = 0
    bar = 0
    foo = x
    for char in symbols:
        foo = foo.replace(char, "")
    for i in range(len(x) + 1):
        if i % 5 == 0 and i != 0:  # making it get a string of len(5)
            y += abs(i - 5)
        if foo[slice(y, i)] in morse_to_digit:  #
            z += morse_to_digit[foo[slice(y, i)]]
            y = 0
        try:
            if x[i+bar] == '.':
                z += '.'
                bar += 1
            elif x[i+bar] in symbols:
                z += x[i+bar]
                bar += 1
        except IndexError:
            pass
    return z


if __name__ == '__main__':
    pass
